Inline: button, span, img

React.createElement(
	“span”,
	{
		id:”sexy-span”,
		style: {color: red},
		onclick: () => console.log(“CLICKED!”)
	},
	“Hello I’m a span”
);

ReactDOM.render(span, root);

두가지는 div의 배열[]에 담기

React.createElement()에 쓰던걸 더 쉽게 : JSX
- (그냥 쓰려면) babel필요
- 필히 대문자 사용
const Title = () => {
	return (
	<h3
	id=“title”
	style={{backgroundColor:”tomato”}}
	onClick={() => console.log(“CLICKED!”)}
	onMouseEnter={functionName}
	>
	I’m a title!
	</h3>
	)}

{JSX에서는 javaScript를 이 {} 안에 적어야 한다. 아니면 그냥 스트링으로 취급돼}

useState: re-render를 자동으로 해준다.
[default value, function to change the value which re-render]
const [food, setFood] = useState[“”]
setCounter( (current) =>current+1);

for -> htmlFor
class -> className

onChange = {onChange}

disabled = true
disabled = false
disabled = {flipped}

value = {flipped ? minutes : Math.round(minutes / 60)}

Html
<select value={index} onChange={onSelect}>
<option value=“0”>


컴포넌트는 단지 JSX를 반환하는 함수


Props: parents component -> child component
property역시 내 임의로 작명하여 보내줄 수 있다.
const Btn = ({ banana }) => {
  return (
    <button
      style={{
        backgroundColor: "tomato",
        color: "white",
        padding: "10px 20px",
      }}
    >
      {banana}
    </button>
  );
};

const App = () => {
  <div>
    <Btn banana="Confirm" />
    {/* 그러면 props에 object가 들어간다
    {banana: "Confirm"} 이렇게 */}
  </div>;
};


const MemorizedBtn = React.memo(Btn)
-> Btn의 같은버전 인데, props 바뀌지 않으면 굳이 re-render하지마!


(이름이야 같을지도 모르지만)
Html에 넣을때는 onClick
Custom component에 onClick 넣을때는 그저 props



























   
