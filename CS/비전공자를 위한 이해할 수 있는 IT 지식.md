# [비전공자를 위한 이해할 수 있는 IT 지식](http://www.yes24.com/Product/Goods/91165789)

## 프로그래밍 언어 & 운영체제(OS)
### 컴파일러
- 컴퓨터와 인간 중간에 컴파일러라는 프로그램을 만듦
- 의사소통이 안되는 인간과 컴퓨터 사이에서 인간의 요구를 컴퓨터에 전달

### IDE(Integrated Development Environment)
- 통합 개발 환경: 개발을 하기 위한 모든 것들을 제공해주는 환경
- 문서 작업을 위해 한컴이나 워드 사용하는 것처럼 코딩에 필요한 다양한 기능들이 들어있고, 그 기능들을 통해 쉽게 코드를 만들 수 있음
- e.g. 안드로이드 스튜디오 for Android, 엑스코드 for iOS 등


### 프로그래밍 언어
- 개발자들은 기존의 것을 발전시키거나 새로운 것을 만들기 좋아하기에 
  - e.g. C언어가 발전(개선)해서 Objective-C, C++, 파이썬
- 저수준(컴퓨터 친화적 언어) vs 고수준(인간 친화적 언어)
  - 저수준: 인간은 배우기 어렵겠지만 컴퓨터 입장에서는 구체적으로 적혀있으니 일하기 쉬우니 낮은 사양에서도 원활히 작동
  - 고수준: 인간이 학습하긴 쉽지만 그만큼 컴퓨터가 더 많이 고민해야하니 저수준 언어보다 작동이 느림
  - 사실 요즘 우리가 쓰는 컴퓨터들은 사양이 아주 좋아서 고수준 언어로 쓰인 문서도 충분히 돌아감
  - 그럼 저수준 언어는 어디서 쓰이는가?: 컴퓨터 사양을 낮춰 가격이 저렴해지면 이득인 경우 e.g. IPTV 셋톱박스 내 컴퓨터

### 컴퓨터의 구성요소
- CPU: 머리
- RAM(메모리): CPU의 개인 작업 공간
- HDD, SDD(보조기억장치): 창고. 전원이 꺼져도 이 안의 데이터는 남아있음. 느림
  - 이 부품들을 메인보드에 끼워서 조립 컴퓨터를 만들 수 있는 것
- 보조기억장치에서 '실행에 필요한 데이터'를 메모리에 올려주고, 이덕분에 CPU가 메모리 위에서 빠르게 작업수행 가능
- e.g. 컴퓨터의 보조기억장치(HDD, SDD)에 카카오톡 실행 파일들이 저장되고, 아이콘을 누르는 순간 실행에 필요한 부분들이 메모리 위로 올라온다. 그리고 CPU가 이 데이터들을 처리하며 카카오톡이 동작한다.

### 운영체제(OS)
- CPU, RAM 등 이 모든것이 낯선이유: 운영체제(Operating System)가 모든 과정을 대신해주기 때문
- 윈도우: C#, Visual Basic, C++, JavaScript, ...
- 맥OS, iOS: Objective-C -> Swift
- 안드로이드: JAVA, Kotlin

## JAVA
- 과거엔 운영체제의 종류가 훨씬 다양해서 개발자가 배워야하는 프로그래밍 언어도 굉장히 많았음
- 10개의 운영체제에서 하나의 버그를 수정하려면 같은 작업을 각 언어로 10번씩 해야만 함
- 이 문제를 자바라는 프로그래밍 언어가 해결: 운영체제에 독립적인 언어
- JVM(Java Virtual Machine)
  - 자바를 만든 팀은 각 운영체제 위애 JVM이라는 소프트웨어를 만듦
  - 사용자가 자신의 컴퓨터에 JVM을 설치하면 운영체제별로 여러개의 프로그램을 만들 필요없이 자바로만 만들면 됨
- 자바 이외에도 다양한 언어(e.g. 파이썬)가 이러한 방식을 취하고 있음
- 단점: 속도가 느리다. 운영체제 위에 프로그램을 올리고, 그 위에 또 프로그램을 돌리는 것이기 때문.
- **모바일의 경우는 PC와 다름**
  1. 현재 모바일 운영체제는 iOS와 안드로이드가 시장 양분. 이 때문에 JVM같은 컨셉에 대한 니즈가 적음(프로그래밍 언어 2개만 알면 되니까)
  2. 모바일의 크기는 PC보다 작기에 용량이나 성능에 제한이 있음. JVM 같이 프로그램 위에 프로그램을 돌린다면 속도 저하
  3. 애플과 구글의 시장 영향력 유지위한 행보


## 네트워크, 클라이언트, 서버
### LAN, MAN, WAN
- LAN(Local Area Network): 컴퓨터가 연결된 작은 지역(Local). LAN을 연결하는 선을 LAN선이라 한다.
- MAN(Metropolitan Area Network): 도시의 여러 LAN을 하나로 연결해 만들어졌다.
- WAN(World Area Network): 도시와 도시, 나라와 나라를 모두 연결해서 만들어졌다.
- 실제로 이 선들을 연결하기 위해 당시 한국에서는 수많은 공사가 이뤄졌으며 정전도 많이 일어났다.
- 더불어 사람들이 이 신호를 무선으로 만들기 시작하여 어느순간 3G, 4G, 5G라는 말들이 오가기 시작했다.

### IP주소
- 해당 컴퓨터가 위치한 주소
- 0~255의 숫자만 사용할 수 있다는 한계 때문에 최근에는 숫자 구분을 4개에서 6개로 늘린 IPv6을 함께 사용하고 있다.

### 우분투(Ubuntu)
- 리눅스는 운영체제다: CPU, 메모리, 보조기억장치들을 우리가 신경쓰지 않아도 된다.  
- 리눅스 위에서는 '서버 프로그램'을 돌린다.
#### 왜 서버 프로그램을 리눅스 위에서 돌릴까?
1. 무료: 아무나 수정가능하며, 수정한 것을 팔아도 괜찮다. (by.리누스 토발스)
2. 잘 만들어진 운영체제

1. 윈도우에도 Windows95, 98, xp 등 다양한 버전이 있듯이 리눅스에도 다양한 버전이 있다. 그리고 그 유명한 버전 중 하나가 우분투(Ubuntu) 이다.
2. 또 다른 유명 버전으로는 레드햇(Red hat) 리눅스: 리눅스를 개량해서 유료로 판매하는 회사
  - 만약 무료 운영체제를 사용하다 고장나면 그 누구에게도 책임을 물을 수 없다.
  - 하지만 레드햇과 같은 회사에서는 운영체제의 품질을 보장하며 유료로 제공
3. 또 다른 유명 개량 버전에는 안드로이드: 구글이 리눅스를 모바일 운영체제 형태로 개량해서 발전시킨 운영체제

### 호스팅 업체
- 개인이 서버를 운영하면 발생하는 리스크를 처리하기 위해 등장한 서비스
- 국내에는 대표적으로 Cafe 24, 가비아, 외국에는 AWS가 있다.
  - AWS는 서버 컴퓨터 대여뿐만 아니라 여러 솔루션을 제공하기도 함


## API
- API는 클라이언트, 서버와 같은 서로 다른 프로그램에서 요청과 응답을 주고 받을 수 있게 만든 체계: 즉, 기능을 사용하기 위해 주소로 요청을 보내면 응답을 해주는 소프트웨어끼리의 체계
- 서버 주소 정의는 서버 개발자의 주도하에 이루어지며, 클라이언트 프로그램은 정해진 주소에 요청을 보낸다: 즉, API는 서버 개발자가 개발하고 클라이언트 개발자는 그 API를 사용한다.
- API를 통해 요청과 응답을 주고 받을 때는 데이터도 같이 담긴다.

### CRUD
- 항상 개발자는 CRUD의 관점에서 데이터를 바라봐야 한다.
- 만약 CRUD 중 특정 기능이 없는 기획이라면 그 의도와 이유가 명확해야한다.

### RESTful API
- 수만개의 주소들이 생기고 관리하기 힘들어지기 시작한다. 또한 프로그래밍은 사람이 하는 일이기 때문에 그 기능이 겹칠 가능성도 있다.
- 따라서 사람들은 좀 더 체계적으로 API를 관리하고 싶어했고, 그 영향으로 **조금 더 체계적인 API라는 사회 운동이 만들어진다. 그런 API를 REST(Representational State Transfer)한 API라고 부른다.**
1. 주소의 개수가 줄어들어 CRUD를 하나의 주소로 관리한다.
2. 요청을 보낼 시 메소드를 함께 전송한다.
  - Create: POST
  - Read: GET
  - Update: PUT(전체), PATCH(일부)
  - Delete: DELETE
- 절대 규칙이 아닌 일종의 사회운동으로, 상황마다 다양한 방식으로 변형해 사용한다.

### 상태코드(Status Code)
- 200번대: Ok
- 400번대: 클라이언트의 요청에서 문제가 있는 경우
- 500번대: 서버에 문제가 있는 경우

### SDK
- Software Development Kit: API를 제공해주는 '다른 소프트웨어'
- 소프트웨어를 개발하기 위한 도구
- e.g. 구글 지도: 다른 회사들도 구글에서 제동하는 지도 SDK를 설치하면 자신의 소프트웨어에 구글 지도 기능을 넣을 수 있다. 

## JSON
- 요청과 응답 시 담기는 데이터의 형식: 무한개의 형식이 만들어 질 수 있다는 문제가 생긴다.
- 각 형식마다 대응하는 코드를 적어줘야하니 비효율적이다.
- 이에 유명한 형식 공유: 과거(XML) => 현재(JSON)

### 도메인 네임
- 숫자로 나열된 IP주소의 불편함을 개선하기 위해 사용
- 도메인 네임만 치면 자동으로 IP주소로 바뀌어 컴퓨터의 위치를 찾는다: 즉, 도메인 네임은 IP주소와 같다.

### 오픈 API(Open API)
- 다양한 기능을 일반 사람들이 쓸 수 있게 오픈해두고 개발자들은 네이버에서 제공하는 API 문서를 보며 그 기능을 사용할 수 있다.
#### 왜 열어 놓았을까?
1. 영향력이 높아진다: 한번이라도 더 네이버 블로그에 들어가게 된다. 영향력은 곧 힘이자 돈이 된다.
2. 비즈니스 모델: 특정 횟수 이상이나 프리미엄 기능


## 애플리케이션
- 애플리케이션은 설치해서 사용하는 모든 프로그램이다.
- 하지만 스마트폰이 등장한 후,
  - 데스크톱에 설치하는 프로그램은 '응용 프로그램'
  - 스마트폰에 설치하는 프로그램은 '앱', '어플', '애플리케이션' 이라고 부르게 되었다.

### 버전(1.0.0)
- 개발자는 '1.0.0'과 같이 자신이 개발한 프로그램에 번호를 부여한다.
- 이 번호를 버전이라고 부르고 점`.`을 기준으로 숫자가 3부분으로 나뉜다.
- (회사마다 정책은 상이하지만) 보통 오른쪽 끝자리는 작은변화 / 중간 숫자는 하위 버전과 호환이 가능하지만 큰 변화 / 왼쪽 끝자리는 하위 버전과 호환이 가능하지 않은 큰 변화
- 보통 게임에서는 업데이트를 강제하는 경우가 많다. 사람들을 조금 귀찮게 해서라도 모든 사람이 같은 버전을 사용하게 만들기 위함.
  - e.g. 업데이트 전 가격공지=10,000원, 업데이트 후 가격공지=20,000원인 황당한 상황을 만들지 않기 위해서.
  - 물론, 그래서 보통 변동이 가능한 회사 정책에 대한 정보는 애플리케이션에 넣지 않고 API로 서버에서 불러오게 만든다.

### 앱생태계
1. [애플](https://developer.apple.com/kr/app-store/review/guidelines/)
#### 단점
- 깐깐하다: 버그가 있으면 앱스토어에 올리는걸 거절한다. 이걸 '리젝'이라고 한다.
- (평균적으로 하루라고 제시는 하지만) 심사기간이 오래걸릴 수 있다.
  - '빠른 심사'를 요청할 수 있지만, 그럼에도 앱스토어의 계획은 보수적으로 세우게 된다.
#### 장점
- 리젝 사유가 명확하며, 해당 문제만 고쳐지면 통과된다.
- 사전 테스트를 깐깐하게 진행하기에 예고 없이 마켓에서 내려지는 경우가 드물다. 
- 물론 지침에 어긋난 사항을 발견하면 경고장을 보내고, 수정되지 않을 경우 앱을 내리는 등 추가 조치를 취하지만 구글보다 논의가 빠르고 활발하다.
#### 앱스토어
- 사전 심사를 깐깐히 하기 때문에 앱의 개수는 구글 플레이 스토어보다 적지만 대부분 정상작동하고 깔끔하다.


2. [안드로이드](https://play.google.com/intl/ko/about/developer-content-policy/)
#### 단점
- 지침에 맞지 않는 앱이 있다면 예고 없이 마켓에서 내려버린다.
- 그리고 복구에 대해 구글과 논의하려면 굉장히 오랜 시간이 걸린다.
#### 장점
- 빠른 시간안에 마켓에 반영된다. (보통 반나절)
#### 구글 플레이 스토어
- 사전 심사가 느슨해 더 많은 앱이 존재하지만 이상하거나 동작하지 않는 앱도 많다.


## 웹
### HTML, CSS, JavaScript
- HTML은 프로그래밍 언어가 아니다. 컴퓨터에게 특정 일을 시킬 수 있는 언어가 아닌, 단지 브라우저가 볼 수 있는 문서를 적는 언어다.
- HTML, CSS, JavaScript 완성본은 모두 서버에 있다. 유저의 컴퓨터에 있는 것은 모두 사본이다.

### 퍼블리싱, 마크업
- HTML과 CSS를 합쳐서 '퍼블리싱' 작업이라고 표현하고, 이 작업을 하는 사람들을 '퍼블리셔'라고 부른다.
- HTML 작업을 마크업 작업이라하며, HTML 작업을 주로 하는 분들을 마크업 개발자라고 한다. (상황에 따라 CSS를 함께 작업하기도 함)

### 웹과 앱의 차이: 업데이트
- 모바일(앱): 애플리케이션을 1.0.0에서 2.0.0으로 변경하기 위해서는 업데이트가 필요하다. 모바일이라면 심사도 필요하다.
  - 단점: 심사, 업데이트 등의 번거로운 과정
  - 장점: 네트워크의 영향을 조금만 받도록 만들 수 있다. e.g. 에버노트: 오프라인 상태로 노트를 작성하고 온라인 상태가 되면 동기화기 이루어진다. 인터넷에 상관없이 서비스를 사용할 수 있게 만든 것.
- 웹: 그저 서버의 원본을 바꾸면 된다. 그러면 '새로 고침' 할 때마다 바뀐 HTML, CSS, JavaScript, 이미지 등의 파일이 다시 다운로드 된다. 심사 과정도 없고 업데이트 과정도 없음.
  - 장점_새로고침: 수정이 용이하다.
  - 단점_새로고침: 항상 새로고침을 해야한다. 이에 네트워크의 영향을 크게 받는다.




































